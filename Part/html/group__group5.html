<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Multi-Way Partitioner Core Engine</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<h1>Multi-Way Partitioner Core Engine</h1>  </div>
<div class="ingroups"><a class="el" href="group__partitioning__group.html">Partitioning Group.</a></div></div>
<div class="contents">
<div class="dynheader">
Collaboration diagram for Multi-Way Partitioner Core Engine:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__group5.png" border="0" alt="" usemap="#group____group5"/>
<map name="group____group5" id="group____group5">
<area shape="rect" id="node2" href="group__partitioning__group.html" title="Partitioning Group." alt="" coords="5,5,136,35"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFMKWayGainArray.html">FMKWayGainArray</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFMKWayGainMgr2.html">FMKWayGainMgr2</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFMKWayGainMgr3.html">FMKWayGainMgr3</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFMKWayGainMgr4.html">FMKWayGainMgr4</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFMKWayMoveStruct.html">FMKWayMoveStruct&lt; A, B &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFMKWayPartComm.html">FMKWayPartComm</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFMKWayPartCore.html">FMKWayPartCore</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFMKWayPartCore4.html">FMKWayPartCore4</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFMKWayPartMgrBase.html">FMKWayPartMgrBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKWayConstrMgr.html">KWayConstrMgr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKWayConstrMgr3.html">KWayConstrMgr3</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKWayConstrMgrBase.html">KWayConstrMgrBase</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This module contains the implementation of Multi-Way FM algorithm and its variants. From "M. Sarrafzadeh and Wong. An Introduction to
 VLSI Design", p 47: "The generlization of the bipartitioning, multiway partitioning, is also an important issue in VLSI design... Most of them adopt a bipartition algorithm iteratively to find a multiway partition. For example, for a four-way partition, we would use the bipartition alogrithm to partition the nodes into two blocks, and then partition each of these blocks into two sub-blocks. As pointed out in [181], a bad result in the first partition may bias the second one (and the rest), if a bipartition alogrithm is used hierarchically. An alternative way to reduce the multi-way partition problem into serveral bipartition problems is to attempt to improve the partition uniformly at each step...Experiments showed that the concept is especially useful for partitioning into a large number of subsets.</p>
<p>From [G. Karypis and V. Kumar, Multilevel k-way Hypergraph Partitioning, 36th Design Automation Conference]: "... Second, a k-way partitioning algorithm is capable of enforcing tighter balancing constraints while retaining the ability to sufficiently explore the feasible solution space to optimize the partitioning objective. This is especially true when the partitioning solution must simultaneously satisfy multiple balancing constraints [21]. Third, a method that obtains a k-way partitioning directly can potentially produce much better partitionings than a method that computes a k-way partitioning via recursive bisection [8] "</p>
<p>From [J. Cong and S. Lim, "Multiway Partitioning with Pairwise
 Movement," Proc. IEEE ICCAD'98]: Recursive approach is a simple extension of bipartitioning to multiway partitioning. It applies bipartitioning recusively until the desired number of partitions is obtained. It is computationing simple and fast, and many of the heuristics devised for bipartitioning can be applied to further reduce the current level cutsize. However, we note three major limitations of the recursive approach. First cells can only move across the current configuration as depicted in Figure 1-(a). The objective of recursive bipartitioning is to redice the number of nets crossing the current level cutline in the absence of global information, which can trap the partitioner into a local minima and limit the solution quality ... Third, it becomes harder and harder to reduce the cutsize as the bipartitioner performs deeper level cuts.Highly optimized 1st and 2nd level cuts can cause 3rd and 4th level cuts to cut through very dense clusters. Thus, this conflicting objective can cause recursive approach to produce low quality multiway partitioning solutions.</p>
<p>Compared with the pairwise movement method, this method may run faster. In flat mode, this method may produce poorer result than the pairwise movement method. However, it seems OK to be used as refinement manager. </p>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
