<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GBPQueue&lt; BPQNode &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>GBPQueue&lt; BPQNode &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__group2.html">Data Structure Group</a></div></h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="GBPQueue" -->
<p><code>#include &lt;<a class="el" href="GBPQueue_8hpp_source.html">GBPQueue.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for GBPQueue&lt; BPQNode &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classGBPQueue__coll__graph.png" border="0" usemap="#GBPQueue_3_01BPQNode_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="GBPQueue_3_01BPQNode_01_4_coll__map" id="GBPQueue_3_01BPQNode_01_4_coll__map">
<area shape="rect" id="node2" href="classGDList.html" title="{GDList\&lt; BPQNode \&gt;\n|&#45; _head\l&#45; _tail\l|+ GDList()\l+ isEmpty()\l+ clear()\l+ first()\l+ first()\l+ last()\l+ last()\l+ pushFront()\l+ pushBack()\l+ pushRandom()\l+ popFront()\l+ popBack()\l+ popFrontFast()\l+ popBackFast()\l+ concat()\l+ isValid()\l+ detach()\l&#45; GDList()\l&#45; makeDummy()\l&#45; operator=()\l&#45; nil()\l&#45; nil()\l* nil()\l* nil()\l}" alt="" coords="17,5,164,507"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classGBPQueue-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBPQueue.html#a1ba97bfceac9887a8a0dbd5f8a32c45f">GBPQueue</a> (int a, int b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a1ba97bfceac9887a8a0dbd5f8a32c45f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBPQueue.html#a8be9712e72f2d263fe8a965a40f5126f">~GBPQueue</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBPQueue.html#a9ab71d24f8b4a9ddcab97d1644d7605f">setUp</a> (int a, int b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup.  <a href="#a9ab71d24f8b4a9ddcab97d1644d7605f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBPQueue.html#a5b168542d090d719b3e6e6fcb45fbf49">getKey</a> (const BPQNode &amp;it) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the key.  <a href="#a5b168542d090d719b3e6e6fcb45fbf49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBPQueue.html#a58a35cf3117e2845b845c3124f44e5ff">getMax</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBPQueue.html#a4e0fe34d4c17433968fc84adb6a3820c">isEmpty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBPQueue.html#ac3984d5956447f27c075c48a59306169">isValid</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBPQueue.html#a4442c9ac6c76f2c338376552fbaad174">makeDummy</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBPQueue.html#aea0b954a560db07f4f15318e1664d30d">clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBPQueue.html#aedc9f969d224c024104a9863a30ae6d6">pushBack</a> (BPQNode &amp;it, int k)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert item at the end of this queue.  <a href="#aedc9f969d224c024104a9863a30ae6d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBPQueue.html#a524780e9f986bbc929d5963dc87390ee">pushBackFast</a> (BPQNode &amp;it, int k)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert item at the end without update the max value.  <a href="#a524780e9f986bbc929d5963dc87390ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBPQueue.html#abb09d5cd3456a1faaecf6146f19bb4e6">resync</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Arbitrarily push item without update the max value.  <a href="#abb09d5cd3456a1faaecf6146f19bb4e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BPQNode &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBPQueue.html#a9d4a11bf116b56f54ceb65076cb734f2">popFront</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBPQueue.html#a53f5478256bb96a1660ac81d2d1cf269">decreaseKeyLIFOBy</a> (BPQNode &amp;it, unsigned int m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease key by m. Precondition: PQ contains it.  <a href="#a53f5478256bb96a1660ac81d2d1cf269"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBPQueue.html#a86540208ae84db6e9ab5708ddfb49f4f">increaseKeyLIFOBy</a> (BPQNode &amp;it, unsigned int m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase key by m. Precondition: PQ contains it.  <a href="#a86540208ae84db6e9ab5708ddfb49f4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9663b3221645d2fe2861aa59ddd9606"></a><!-- doxytag: member="GBPQueue::promote" ref="af9663b3221645d2fe2861aa59ddd9606" args="(BPQNode &amp;it)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>promote</b> (BPQNode &amp;it)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a507d79b963ef5dab1001e0b9d908a19b"></a><!-- doxytag: member="GBPQueue::demote" ref="a507d79b963ef5dab1001e0b9d908a19b" args="(BPQNode &amp;it)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>demote</b> (BPQNode &amp;it)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBPQueue.html#af5fe7ea58f7c9453fb91401a5352f713">decreaseKeyBy</a> (BPQNode &amp;it, unsigned int m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease key by m. Precondition: PQ contains it.  <a href="#af5fe7ea58f7c9453fb91401a5352f713"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBPQueue.html#a929045564fb45fbfe49046de90859f18">increaseKeyBy</a> (BPQNode &amp;it, unsigned int m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase key by m. Precondition: PQ contains it.  <a href="#a929045564fb45fbfe49046de90859f18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBPQueue.html#a3000cd6361e5ef3afa2e5d3c1139e13a">modifyKeyLIFOBy</a> (BPQNode &amp;it, int m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify key by m. Precondition: PQ contains it.  <a href="#a3000cd6361e5ef3afa2e5d3c1139e13a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBPQueue.html#abbd1cd0c2786d32f083267ef8bc97dfd">modifyKeyBy</a> (BPQNode &amp;it, int m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify key by m. Precondition: PQ contains it.  <a href="#abbd1cd0c2786d32f083267ef8bc97dfd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBPQueue.html#a162aca834ac46fd313c128e5a9a06b3f">detach</a> (BPQNode &amp;it)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBPQueue.html#ad234f9c1264038a8ebffc5c96c54ecec">pushTo</a> (<a class="el" href="classGDList.html">GDList</a>&lt; BPQNode &gt; &amp;list)</td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04f6844704d98fc08508e678bca40184"></a><!-- doxytag: member="GBPQueue::GBPQueueCursor&lt; BPQNode &gt;" ref="a04f6844704d98fc08508e678bca40184" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBPQueue.html#a04f6844704d98fc08508e678bca40184">GBPQueueCursor&lt; BPQNode &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19a947617cd4964e011456444db736c7"></a><!-- doxytag: member="GBPQueue::GBPQueueConstCursor&lt; BPQNode &gt;" ref="a19a947617cd4964e011456444db736c7" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>GBPQueueConstCursor&lt; BPQNode &gt;</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class BPQNode&gt;<br/>
 class GBPQueue&lt; BPQNode &gt;</h3>

<p>Bounded Priority Queue with integer keys in [a..b]. Implemented by array (bucket) of doubly-linked lists. Efficient if key is bounded by a small integer value. Note that this class does not own the PQ nodes, even though PQ node class is defined in this header file. This feature makes the nodes sharable between doubly linked list class and this class. In the FM algorithm, the node either attached to the gain buckets (PQ) or in the freeVertexList (doubly linked list), but not in both of them in the same time.</p>
<p>Another improvement is to make the array size one element bigger i.e. (b - a + 2). The extra dummy array element (which is T[0]) is used to reduce the boundary checking during updating.</p>
<p>All the member functions assume that the keys are within the bound. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1ba97bfceac9887a8a0dbd5f8a32c45f"></a><!-- doxytag: member="GBPQueue::GBPQueue" ref="a1ba97bfceac9887a8a0dbd5f8a32c45f" args="(int a, int b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BPQNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGBPQueue.html">GBPQueue</a>&lt; BPQNode &gt;::<a class="el" href="classGBPQueue.html">GBPQueue</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>lower bound </td></tr>
    <tr><td class="paramname">b</td><td>upper bound Precondition: a &lt;= b </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8be9712e72f2d263fe8a965a40f5126f"></a><!-- doxytag: member="GBPQueue::~GBPQueue" ref="a8be9712e72f2d263fe8a965a40f5126f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BPQNode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGBPQueue.html">GBPQueue</a>&lt; BPQNode &gt;::~<a class="el" href="classGBPQueue.html">GBPQueue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aea0b954a560db07f4f15318e1664d30d"></a><!-- doxytag: member="GBPQueue::clear" ref="aea0b954a560db07f4f15318e1664d30d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BPQNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGBPQueue.html">GBPQueue</a>&lt; BPQNode &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset the PQ. </p>

</div>
</div>
<a class="anchor" id="af5fe7ea58f7c9453fb91401a5352f713"></a><!-- doxytag: member="GBPQueue::decreaseKeyBy" ref="af5fe7ea58f7c9453fb91401a5352f713" args="(BPQNode &amp;it, unsigned int m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BPQNode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGBPQueue.html">GBPQueue</a>&lt; BPQNode &gt;::decreaseKeyBy </td>
          <td>(</td>
          <td class="paramtype">BPQNode &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decrease key by m. Precondition: PQ contains it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>the item </td></tr>
    <tr><td class="paramname">m</td><td>the change of key Note that order of items with same key will be preserved. For FM algorithm, this is a prefered behavior. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classGDList.html#a26eec3ff5320ce19418c017c1f4ed5ce">GDList&lt; DNode &gt;::detach()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classGBPQueue_af5fe7ea58f7c9453fb91401a5352f713_cgraph.png" border="0" usemap="#classGBPQueue_af5fe7ea58f7c9453fb91401a5352f713_cgraph" alt=""/></div>
<map name="classGBPQueue_af5fe7ea58f7c9453fb91401a5352f713_cgraph" id="classGBPQueue_af5fe7ea58f7c9453fb91401a5352f713_cgraph">
<area shape="rect" id="node3" href="classGDList.html#a26eec3ff5320ce19418c017c1f4ed5ce" title="GDList::detach" alt="" coords="244,5,353,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a53f5478256bb96a1660ac81d2d1cf269"></a><!-- doxytag: member="GBPQueue::decreaseKeyLIFOBy" ref="a53f5478256bb96a1660ac81d2d1cf269" args="(BPQNode &amp;it, unsigned int m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BPQNode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGBPQueue.html">GBPQueue</a>&lt; BPQNode &gt;::decreaseKeyLIFOBy </td>
          <td>(</td>
          <td class="paramtype">BPQNode &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decrease key by m. Precondition: PQ contains it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>the item </td></tr>
    <tr><td class="paramname">m</td><td>the change of key Note that order of items with same key will not be preserved. For FM algorithm, this is a prefered behavior. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classGDList.html#a26eec3ff5320ce19418c017c1f4ed5ce">GDList&lt; DNode &gt;::detach()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classGBPQueue_a53f5478256bb96a1660ac81d2d1cf269_cgraph.png" border="0" usemap="#classGBPQueue_a53f5478256bb96a1660ac81d2d1cf269_cgraph" alt=""/></div>
<map name="classGBPQueue_a53f5478256bb96a1660ac81d2d1cf269_cgraph" id="classGBPQueue_a53f5478256bb96a1660ac81d2d1cf269_cgraph">
<area shape="rect" id="node3" href="classGDList.html#a26eec3ff5320ce19418c017c1f4ed5ce" title="GDList::detach" alt="" coords="273,5,383,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a162aca834ac46fd313c128e5a9a06b3f"></a><!-- doxytag: member="GBPQueue::detach" ref="a162aca834ac46fd313c128e5a9a06b3f" args="(BPQNode &amp;it)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BPQNode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGBPQueue.html">GBPQueue</a>&lt; BPQNode &gt;::detach </td>
          <td>(</td>
          <td class="paramtype">BPQNode &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Detach the item from this queue. Precondition: PQ contains it </p>

<p>References <a class="el" href="classGDList.html#a26eec3ff5320ce19418c017c1f4ed5ce">GDList&lt; DNode &gt;::detach()</a>.</p>

<p>Referenced by <a class="el" href="classGBPQueueTestCase.html#a1460fb4bfcdfbfcebcc0939dbf631917">GBPQueueTestCase::testCursors()</a>, <a class="el" href="classFMKWayGainMgr4.html#a66d8600680c54acbb4e99aff5deeb323">FMKWayGainMgr4::updateMove()</a>, <a class="el" href="classFMKWayGainMgr2.html#a9f79e9457559b0a2d4c1b15530cd076b">FMKWayGainMgr2::updateMove()</a>, and <a class="el" href="classFMBiGainMgr2.html#a56d57465dbc324c3500b5b310ae064b1">FMBiGainMgr2::updateMove()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classGBPQueue_a162aca834ac46fd313c128e5a9a06b3f_cgraph.png" border="0" usemap="#classGBPQueue_a162aca834ac46fd313c128e5a9a06b3f_cgraph" alt=""/></div>
<map name="classGBPQueue_a162aca834ac46fd313c128e5a9a06b3f_cgraph" id="classGBPQueue_a162aca834ac46fd313c128e5a9a06b3f_cgraph">
<area shape="rect" id="node3" href="classGDList.html#a26eec3ff5320ce19418c017c1f4ed5ce" title="GDList::detach" alt="" coords="191,5,300,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5b168542d090d719b3e6e6fcb45fbf49"></a><!-- doxytag: member="GBPQueue::getKey" ref="a5b168542d090d719b3e6e6fcb45fbf49" args="(const BPQNode &amp;it) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BPQNode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classGBPQueue.html">GBPQueue</a>&lt; BPQNode &gt;::getKey </td>
          <td>(</td>
          <td class="paramtype">const BPQNode &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the key. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>the item </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the key of it. </dd></dl>

<p>Referenced by <a class="el" href="classFMKWayGainMgr4.html#a0f6d3d2c5df31e2de43c496bfd5bc935">FMKWayGainMgr4::getGain()</a>, <a class="el" href="classFMKWayGainMgr2.html#ab2b1bf7f1c01469933c5e44baa7e343a">FMKWayGainMgr2::getGain()</a>, <a class="el" href="classFMBiGainMgr2.html#a6520407d8e1b34f5e772eed8b76cd1ee">FMBiGainMgr2::getGain()</a>, and <a class="el" href="group__group3.html#gaa9d4bdf467bcb890d5ac9cadb20b5843">FMBiGainMgr::getGain()</a>.</p>

</div>
</div>
<a class="anchor" id="a58a35cf3117e2845b845c3124f44e5ff"></a><!-- doxytag: member="GBPQueue::getMax" ref="a58a35cf3117e2845b845c3124f44e5ff" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BPQNode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classGBPQueue.html">GBPQueue</a>&lt; BPQNode &gt;::getMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the max value. </dd></dl>

</div>
</div>
<a class="anchor" id="a929045564fb45fbfe49046de90859f18"></a><!-- doxytag: member="GBPQueue::increaseKeyBy" ref="a929045564fb45fbfe49046de90859f18" args="(BPQNode &amp;it, unsigned int m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BPQNode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGBPQueue.html">GBPQueue</a>&lt; BPQNode &gt;::increaseKeyBy </td>
          <td>(</td>
          <td class="paramtype">BPQNode &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increase key by m. Precondition: PQ contains it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>the item </td></tr>
    <tr><td class="paramname">m</td><td>the change of key Note that order of items with same key will be preserved. For FM algorithm, this is a prefered behavior. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classGDList.html#a26eec3ff5320ce19418c017c1f4ed5ce">GDList&lt; DNode &gt;::detach()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classGBPQueue_a929045564fb45fbfe49046de90859f18_cgraph.png" border="0" usemap="#classGBPQueue_a929045564fb45fbfe49046de90859f18_cgraph" alt=""/></div>
<map name="classGBPQueue_a929045564fb45fbfe49046de90859f18_cgraph" id="classGBPQueue_a929045564fb45fbfe49046de90859f18_cgraph">
<area shape="rect" id="node3" href="classGDList.html#a26eec3ff5320ce19418c017c1f4ed5ce" title="GDList::detach" alt="" coords="239,5,348,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a86540208ae84db6e9ab5708ddfb49f4f"></a><!-- doxytag: member="GBPQueue::increaseKeyLIFOBy" ref="a86540208ae84db6e9ab5708ddfb49f4f" args="(BPQNode &amp;it, unsigned int m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BPQNode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGBPQueue.html">GBPQueue</a>&lt; BPQNode &gt;::increaseKeyLIFOBy </td>
          <td>(</td>
          <td class="paramtype">BPQNode &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increase key by m. Precondition: PQ contains it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>the item </td></tr>
    <tr><td class="paramname">m</td><td>the change of key Note that order of items with same key will not be preserved. For FM algorithm, this is a prefered behavior. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classGDList.html#a26eec3ff5320ce19418c017c1f4ed5ce">GDList&lt; DNode &gt;::detach()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classGBPQueue_a86540208ae84db6e9ab5708ddfb49f4f_cgraph.png" border="0" usemap="#classGBPQueue_a86540208ae84db6e9ab5708ddfb49f4f_cgraph" alt=""/></div>
<map name="classGBPQueue_a86540208ae84db6e9ab5708ddfb49f4f_cgraph" id="classGBPQueue_a86540208ae84db6e9ab5708ddfb49f4f_cgraph">
<area shape="rect" id="node3" href="classGDList.html#a26eec3ff5320ce19418c017c1f4ed5ce" title="GDList::detach" alt="" coords="268,5,377,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a4e0fe34d4c17433968fc84adb6a3820c"></a><!-- doxytag: member="GBPQueue::isEmpty" ref="a4e0fe34d4c17433968fc84adb6a3820c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BPQNode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGBPQueue.html">GBPQueue</a>&lt; BPQNode &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the PQ is empty. </dd></dl>

<p>Referenced by <a class="el" href="classCycleRemovalServ.html#aae377950c2e15dd44d40f9bfc4c3e8cf">CycleRemovalServ::doRemove()</a>, <a class="el" href="classGBPQueueTestCase.html#a1460fb4bfcdfbfcebcc0939dbf631917">GBPQueueTestCase::testCursors()</a>, and <a class="el" href="classGBPQueueTestCase.html#aa7a1b354ec5c3e2bfcb062cad59cda33">GBPQueueTestCase::testPushPop()</a>.</p>

</div>
</div>
<a class="anchor" id="ac3984d5956447f27c075c48a59306169"></a><!-- doxytag: member="GBPQueue::isValid" ref="ac3984d5956447f27c075c48a59306169" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BPQNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGBPQueue.html">GBPQueue</a>&lt; BPQNode &gt;::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the PQ is valid. Take O(n) time. </dd></dl>

</div>
</div>
<a class="anchor" id="a4442c9ac6c76f2c338376552fbaad174"></a><!-- doxytag: member="GBPQueue::makeDummy" ref="a4442c9ac6c76f2c338376552fbaad174" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BPQNode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGBPQueue.html">GBPQueue</a>&lt; BPQNode &gt;::makeDummy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>(For restricted used only) Make dummy. </p>

</div>
</div>
<a class="anchor" id="abbd1cd0c2786d32f083267ef8bc97dfd"></a><!-- doxytag: member="GBPQueue::modifyKeyBy" ref="abbd1cd0c2786d32f083267ef8bc97dfd" args="(BPQNode &amp;it, int m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BPQNode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGBPQueue.html">GBPQueue</a>&lt; BPQNode &gt;::modifyKeyBy </td>
          <td>(</td>
          <td class="paramtype">BPQNode &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modify key by m. Precondition: PQ contains it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>the item </td></tr>
    <tr><td class="paramname">m</td><td>the change of key Note that order of items with same key will be preserved. For FM algorithm, this is a prefered behavior. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classFMKWayGainMgr3.html#a85b122c5ff25cdab78eabb5b69eebd4c">FMKWayGainMgr3::updateNeighbor()</a>, and <a class="el" href="group__group3.html#ga178e4046bd22caac0c4dcc1008b554f2">FMBiGainMgr3::updateNeighbor()</a>.</p>

</div>
</div>
<a class="anchor" id="a3000cd6361e5ef3afa2e5d3c1139e13a"></a><!-- doxytag: member="GBPQueue::modifyKeyLIFOBy" ref="a3000cd6361e5ef3afa2e5d3c1139e13a" args="(BPQNode &amp;it, int m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BPQNode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGBPQueue.html">GBPQueue</a>&lt; BPQNode &gt;::modifyKeyLIFOBy </td>
          <td>(</td>
          <td class="paramtype">BPQNode &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modify key by m. Precondition: PQ contains it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>the item </td></tr>
    <tr><td class="paramname">m</td><td>the change of key Note that order of items with same key will not be preserved. For FM algorithm, this is a prefered behavior. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classFMKWayGainMgr4.html#a497b7a025699c0f1e3941fa280c2ce45">FMKWayGainMgr4::updateNeighbor()</a>, <a class="el" href="classFMKWayGainMgr2.html#ab5060af283f1ba1e681e9494469e2548">FMKWayGainMgr2::updateNeighbor()</a>, <a class="el" href="classFMBiGainMgr2.html#a9de549601a25284c14da04cf8f2dac4a">FMBiGainMgr2::updateNeighbor()</a>, and <a class="el" href="group__group3.html#ga3d9902a92f7a744faa20dbb77ea0e5fc">FMBiGainMgr::updateNeighbor()</a>.</p>

</div>
</div>
<a class="anchor" id="a9d4a11bf116b56f54ceb65076cb734f2"></a><!-- doxytag: member="GBPQueue::popFront" ref="a9d4a11bf116b56f54ceb65076cb734f2" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BPQNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BPQNode &amp; <a class="el" href="classGBPQueue.html">GBPQueue</a>&lt; BPQNode &gt;::popFront </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pop an item with highest key. Precondition: PQ is not empty. </p>

<p>Referenced by <a class="el" href="classCycleRemovalServ.html#a024dbf174a6efb7b28bcabf2f23fc013">CycleRemovalServ::handleNextBest()</a>, and <a class="el" href="classGBPQueueTestCase.html#aa7a1b354ec5c3e2bfcb062cad59cda33">GBPQueueTestCase::testPushPop()</a>.</p>

</div>
</div>
<a class="anchor" id="aedc9f969d224c024104a9863a30ae6d6"></a><!-- doxytag: member="GBPQueue::pushBack" ref="aedc9f969d224c024104a9863a30ae6d6" args="(BPQNode &amp;it, int k)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BPQNode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGBPQueue.html">GBPQueue</a>&lt; BPQNode &gt;::pushBack </td>
          <td>(</td>
          <td class="paramtype">BPQNode &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert item at the end of this queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>the item </td></tr>
    <tr><td class="paramname">k</td><td>the key Precondition: PQ does not contain it; a &lt;= k &lt;= b. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classFMKWayGainMgr4.html#abc6916943e47a4e17d9af87368de76e0">FMKWayGainMgr4::pushBack()</a>, <a class="el" href="classFMKWayGainMgr2.html#a21285c0e514f922f0faae5a72251404f">FMKWayGainMgr2::pushBack()</a>, <a class="el" href="classFMBiGainMgr2.html#a5b2266303b34c461163a1b0888d15d53">FMBiGainMgr2::pushBack()</a>, <a class="el" href="group__group3.html#ga1993a4fcdbbc66159fdb5af876b03c5d">FMBiGainMgr::pushBack()</a>, <a class="el" href="classGBPQueueTestCase.html#a1460fb4bfcdfbfcebcc0939dbf631917">GBPQueueTestCase::testCursors()</a>, and <a class="el" href="classGBPQueueTestCase.html#aa7a1b354ec5c3e2bfcb062cad59cda33">GBPQueueTestCase::testPushPop()</a>.</p>

</div>
</div>
<a class="anchor" id="a524780e9f986bbc929d5963dc87390ee"></a><!-- doxytag: member="GBPQueue::pushBackFast" ref="a524780e9f986bbc929d5963dc87390ee" args="(BPQNode &amp;it, int k)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BPQNode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGBPQueue.html">GBPQueue</a>&lt; BPQNode &gt;::pushBackFast </td>
          <td>(</td>
          <td class="paramtype">BPQNode &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert item at the end without update the max value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>the item </td></tr>
    <tr><td class="paramname">k</td><td>the key Precondition: PQ does not contain it; a &lt;= k &lt;= b. Call <a class="el" href="classGBPQueue.html#abb09d5cd3456a1faaecf6146f19bb4e6" title="Arbitrarily push item without update the max value.">resync()</a> after calling this method. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classNetlist.html#a5c29a680811201f1e54ae1756081a161">Netlist::firstChoice()</a>, <a class="el" href="classNetlist.html#a689bc5f61509fbd2fb0373da8dbc6394">Netlist::maximumIndependentSet()</a>, and <a class="el" href="classCycleRemovalServ.html#a5c391280b054d245e84f33f5eba1461c">CycleRemovalServ::setup()</a>.</p>

</div>
</div>
<a class="anchor" id="ad234f9c1264038a8ebffc5c96c54ecec"></a><!-- doxytag: member="GBPQueue::pushTo" ref="ad234f9c1264038a8ebffc5c96c54ecec" args="(GDList&lt; BPQNode &gt; &amp;list)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BPQNode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGBPQueue.html">GBPQueue</a>&lt; BPQNode &gt;::pushTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGDList.html">GDList</a>&lt; BPQNode &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Push all the items into a given list. This BPQueue becomes empty after this operation. </p>

<p>References <a class="el" href="classGDList.html#aeaa782c6df1c982650b389bdcc2d4eeb">GDList&lt; DNode &gt;::concat()</a>.</p>

<p>Referenced by <a class="el" href="classNetlist.html#a5c29a680811201f1e54ae1756081a161">Netlist::firstChoice()</a>, and <a class="el" href="classNetlist.html#a689bc5f61509fbd2fb0373da8dbc6394">Netlist::maximumIndependentSet()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classGBPQueue_ad234f9c1264038a8ebffc5c96c54ecec_cgraph.png" border="0" usemap="#classGBPQueue_ad234f9c1264038a8ebffc5c96c54ecec_cgraph" alt=""/></div>
<map name="classGBPQueue_ad234f9c1264038a8ebffc5c96c54ecec_cgraph" id="classGBPQueue_ad234f9c1264038a8ebffc5c96c54ecec_cgraph">
<area shape="rect" id="node3" href="classGDList.html#aeaa782c6df1c982650b389bdcc2d4eeb" title="GDList::concat" alt="" coords="193,5,303,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="abb09d5cd3456a1faaecf6146f19bb4e6"></a><!-- doxytag: member="GBPQueue::resync" ref="abb09d5cd3456a1faaecf6146f19bb4e6" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BPQNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGBPQueue.html">GBPQueue</a>&lt; BPQNode &gt;::resync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Arbitrarily push item without update the max value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>the item </td></tr>
    <tr><td class="paramname">k</td><td>the key Precondition: PQ does not contain it; a &lt;= k &lt;= b. Call <a class="el" href="classGBPQueue.html#abb09d5cd3456a1faaecf6146f19bb4e6" title="Arbitrarily push item without update the max value.">resync()</a> after calling this method. Update the max value </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classNetlist.html#a5c29a680811201f1e54ae1756081a161">Netlist::firstChoice()</a>, <a class="el" href="classNetlist.html#a689bc5f61509fbd2fb0373da8dbc6394">Netlist::maximumIndependentSet()</a>, and <a class="el" href="classCycleRemovalServ.html#a5c391280b054d245e84f33f5eba1461c">CycleRemovalServ::setup()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ab71d24f8b4a9ddcab97d1644d7605f"></a><!-- doxytag: member="GBPQueue::setUp" ref="a9ab71d24f8b4a9ddcab97d1644d7605f" args="(int a, int b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BPQNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGBPQueue.html">GBPQueue</a>&lt; BPQNode &gt;::setUp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setup. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>lower bound </td></tr>
    <tr><td class="paramname">b</td><td>upper bound Precondition: a &lt;= b </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group__group3.html#gac1968a9468d8a6fce6a4358197223794">FMBiGainMgr::FMBiGainMgr()</a>, <a class="el" href="classFMBiGainMgr2.html#a781393b972faf4406b4268b38c6a2652">FMBiGainMgr2::FMBiGainMgr2()</a>, <a class="el" href="classFMKWayGainMgr2.html#aa1b7d99dabf6df029f7ee569dcaf9e1c">FMKWayGainMgr2::FMKWayGainMgr2()</a>, <a class="el" href="classFMKWayGainMgr4.html#abd066349b7ecedd82736b6d2b00bba7f">FMKWayGainMgr4::FMKWayGainMgr4()</a>, and <a class="el" href="classGBPQueue2.html#a7bb01016f85ef27f400f35e9d9b54a7c">GBPQueue2&lt; BPQNode &gt;::setUp()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="GBPQueue_8hpp_source.html">GBPQueue.hpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
